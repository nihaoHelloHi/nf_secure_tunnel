# 自定义传输层协议NST
- 协议复用点
  - 复用tcp_prot、udp_prot
  - 复用inet_stream_ops、inet_dgram_ops
- 协议修改点
  - 在tcp_sendmsg、udp_sendmsg前修改和加密数据
  - 在tcp_sendmsg、udp_recvmsg还原数据
- 有关netfilter
  - 在LOCAL_IN阶段进行检查
- 使用协议需要**用户层代码改变**
  - 用户层代码创建socket时指定NST协议
  - TCP:```socket(AF_NST, NST_SOCK_STREAM, 0)```
  - UDP:```socket(AF_NST, NST_SOCK_DGRAM, 0)```
- 待考证的细节
  - tcp握手是否独立于tcp_sendmsg、tcp_recv
  - 是否需要修改sendpage
  - msghdr如何进行修改和加密

## 整体流程
![img.png](z-img/img.png)

## 头部设计
``` c
// 4+1+1+2+8+8+16+1+1+2+4 = 48(B)
struct nst_hdr {
    __be32 magic;                   // 魔数标识协议
    u8 version;                     // 协议版本
    u8 cipher_id;                   // 加密算法ID
    __be16 transport_len;             // 明文 payload 长度
    __be64 timestamp;               // 时间戳，防重放
    __be64 nonce;                   // 随机数/计数器
    u8 token[NST_TOKEN_LEN];        // 认证字段（对称或HMAC）
    u8 kpos;                    // 秘钥改变位置, 0表示不修改
    u8 kval;                    // 秘钥改变值
    __be16 kid;                     // 秘钥id
    __be32 flags;                   // 保留标志位
} __attribute__((packed));          // 取消结构对齐
```

## 加密算法
```
#define ENCRYPT_ALGO_AES_GCM 1
#define ENCRYPT_ALGO_AES_CBC 2
#define ENCRYPT_ALGO_SM4_GCM 3 // 国密
#define ENCRYPT_ALGO_SM4_CBC 4 // 国密
```
当前思路：采用对称加密算法+静态随机密钥盒+密钥扰动

## 具体待解决问题
1. 如何复用`PF_INET`的TCP/UDP
2. `struct msghdr`如何加密和重构
3. 防重放的结构如何组织，在recv进行还是LOCAL_OUT进行
4. 模块开关
5. 数据还原