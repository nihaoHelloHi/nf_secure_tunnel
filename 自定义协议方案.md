# 自定义传输层协议NST
- 协议复用点
  - 复用tcp_prot、udp_prot
  - 复用inet_stream_ops、inet_dgram_ops
- 协议修改点
  - 在tcp_sendmsg、udp_sendmsg前修改和加密数据
  - 在tcp_sendmsg、udp_recvmsg还原数据
- 有关netfilter
  - 在LOCAL_IN阶段进行检查
- 使用协议需要**用户层代码改变**
  - 用户层代码创建socket时指定NST协议
  - TCP:```socket(AF_NST, NST_SOCK_STREAM, 0)```
  - UDP:```socket(AF_NST, NST_SOCK_DGRAM, 0)```
- 待考证的细节
  - tcp握手是否独立于tcp_sendmsg、tcp_recv
  - 是否需要修改sendpage
  - msghdr如何进行修改和加密

## 整体流程
![img.png](z-img/img.png)

## 头部设计
``` c
// 4+1+1+2+8+8+16+1+1+2+4 = 48(B)
struct nst_hdr {
    __be32 magic;                   // 魔数标识协议
    u8 version;                     // 协议版本
    u8 cipher_id;                   // 加密算法ID
    __be16 transport_len;             // 明文 payload 长度
    __be64 timestamp;               // 时间戳，防重放
    __be64 nonce;                   // 随机数/计数器
    u8 token[NST_TOKEN_LEN];        // 认证字段（对称或HMAC）
    u8 kpos;                    // 秘钥改变位置, 0表示不修改
    u8 kval;                    // 秘钥改变值
    __be16 kid;                     // 秘钥id
    __be32 flags;                   // 保留标志位
} __attribute__((packed));          // 取消结构对齐
```

## 加密算法
```
#define ENCRYPT_ALGO_AES_GCM 1
#define ENCRYPT_ALGO_AES_CBC 2
#define ENCRYPT_ALGO_SM4_GCM 3 // 国密
#define ENCRYPT_ALGO_SM4_CBC 4 // 国密
```
当前思路：采用对称加密算法+静态随机密钥盒+密钥扰动

## 具体待解决问题
1. 如何复用`PF_INET`的TCP/UDP
2. `struct msghdr`如何加密和重构
3. 防重放的结构如何组织，在recv进行还是LOCAL_OUT进行
4. 模块开关
5. 数据还原


# 相似工作调研
## 1. linux官方KTLS
示例：
**用户空间完成tls握手**，并将密钥使用`setsockopt`传输给内核，此后内核将自动加密解密。
``` c
SSL *ssl = SSL_new(ctx);
SSL_set_fd(ssl, sockfd);

// 1. 完成握手（用户态执行）
SSL_connect(ssl);

// 2. 获取加密参数
SSL_export_keying_material(...); // 导出密钥、iv、seq

// 3. 配置内核TLS加密
struct tls12_crypto_info_aes_gcm_128 crypto = { ... };
setsockopt(sockfd, SOL_TLS, TLS_TX, &crypto, sizeof(crypto));

// 4. 发送数据（内核自动加密）
send(sockfd, "Hello", 5, 0);  // KTLS 自动加密发送
```

## 2. AF_KTLS 内核模块

**注意：该实现仍处于高度开发中，使用风险自负！**

该内核模块引入了一种新的套接字协议族：`AF_KTLS`。`AF_KTLS` 套接字可以用于在 **TCP** 上通过 **TLS 1.2** 或在 **UDP** 上通过 **DTLS 1.2** 传输数据。目前，仅支持 **AES GCM** 加密套件。

该套接字仅负责数据传输，而诸如 **握手（handshake）**、**重新握手（re-handshaking）** 以及其他控制信息的处理需要用户空间通过如 **OpenSSL** 或 **GnuTLS** 等库来完成。

AF\_KTLS 套接字在某些场景下传输速度更快，尤其是在无需用户空间干预的数据传输中（例如使用 `sendfile(2)` 或 `splice(2)` 实现的零拷贝传输）。

该套接字基于 **RFC 5288**，该标准最初由 Facebook 的 **Dave Watson** 在 Linux 加密邮件列表中提出。该仓库中包含了 RFC 5288 的最新补丁。

如需了解基准测试场景或评估你自己的用例性能影响，请参阅配套的 **AF\_KTLS 工具**。

可以在项目的 Issues 中查看待实现的功能或已知的 Bug。

推荐同时参考：

* **AF\_KTLS tool（测试工具）**
* **AF\_KTLS visualize（可视化工具）**

### 架构设计
``` 
应用层：   [用户应用程序]
TLS层：    [AF_KTLS 套接字]
传输层：   [TCP/UDP 套接字]
网络层：   [IP 协议栈]
```
流程：
1. 用户应用程序创建TCP/UDP连接， 每一个连接创建一个ktls套接字
2. 用户空间调用openssl_connect进行握手获取密钥，
3. 使用`密钥`和连接`fd`构建sockaddr_ktls， 
4. 并调用tls_bind（sockaddr_ktls）绑定ktls套接字， 
5. bind替换数据就绪/写空间回调

### 与底层socket的关联操作
你的问题非常好，涉及到 `af_ktls.c` 中 TLS 绑定 (`tls_bind`) 和数据发送/接收 (`tls_sendmsg` 和 `tls_recvmsg`) 之间的具体实现机制。让我逐步解释清楚 `tls_bind` 如何替换底层 socket 的读写回调，以及 `tls_sendmsg` 和 `tls_recvmsg` 如何将数据添加到底层的 TCP/UDP socket 中。

#### 1. `tls_bind` 中的回调替换机制
在 `tls_bind` 函数中，`af_ktls.c` 将底层 socket（TCP 或 UDP）的读写回调替换为自定义的 KTLS 回调。这是通过操作 `sk_callback_lock` 实现的，具体代码片段如下：

```c
write_lock_bh(&tsk->socket->sk->sk_callback_lock);
tsk->rx_stopped = 0;
tsk->saved_sk_data_ready = tsk->socket->sk->sk_data_ready;
tsk->saved_sk_write_space = tsk->socket->sk->sk_write_space;
tsk->socket->sk->sk_data_ready = tls_data_ready;
tsk->socket->sk->sk_write_space = tls_write_space;
tsk->socket->sk->sk_user_data = tsk;
write_unlock_bh(&tsk->socket->sk->sk_callback_lock);
```

- **机制**：
  - `sk_callback_lock` 是一个自旋锁，确保回调的修改是线程安全的。
  - 原来的 `sk_data_ready`（数据就绪回调）和 `sk_write_space`（写空间可用回调）被保存到 `saved_sk_data_ready` 和 `saved_sk_write_space`，以便后续可能恢复。
  - 新的回调 `tls_data_ready` 和 `tls_write_space` 被设置为 KTLS 的自定义处理逻辑。
  - `sk_user_data` 被设置为 `tsk`（`tls_sock` 结构），方便在回调中访问 KTLS 上下文。

- **目的**：
  - 替换后，当底层 socket 有数据到达或写空间可用时，会触发 KTLS 的 `tls_data_ready` 或 `tls_write_space`，而不是直接通知用户空间。这允许 KTLS 在数据传输前进行加密/解密处理。

#### 2. `tls_sendmsg` 如何将数据添加到底层 TCP/UDP socket
`tls_sendmsg` 函数负责处理用户发送的数据，并将其加密后通过底层 socket 发送。关键点在于它并不直接操作数据，而是通过工作队列和内核发送机制将数据传递给底层 socket。以下是实现过程：

 实现细节：
- **数据缓冲和加密**：
  - `tls_sendmsg` 首先检查 `KTLS_SEND_READY(tsk)`，确保密钥和初始化向量已准备好。
  - 它使用 `msg_iov` 从用户空间收集分散的缓冲区数据，存储到 `sk_buff` 队列 (`sk->sk_write_queue`) 中。
  - 数据被分片（不超过 `KTLS_MAX_PAYLOAD_SIZE`），并通过 `tls_pre_encrypt` 和 `tls_do_encryption` 进行 AES-GCM 加密，生成加密后的数据存储在 `tsk->pages_send`（页面缓冲区）中。

- **工作队列触发**：
  - 加密后的数据准备好后，`tls_push` 函数被调用，设置 `tsk->send_len` 和 `tsk->send_offset`，并通过 `tls_kernel_sendpage` 将数据发送。
  - `tls_kernel_sendpage` 使用 `kernel_sendpage` 将加密数据页面发送到底层 socket（`tsk->socket`），这是内核空间的发送接口。
  - 为了异步处理，`tls_tx_work` 工作队列被触发（通过 `INIT_WORK` 和 `queue_work`），确保发送操作在后台完成。

- **底层 socket 的角色**：
  - 底层 TCP/UDP socket 的 `sendmsg` 或 `sendpage` 方法最终被调用（由 `tsk->socket->ops` 提供，例如 TCP 的 `tcp_sendmsg` 或 UDP 的 `udp_sendmsg`）。
  - 数据通过 `kernel_sendpage` 直接传递给底层协议栈，底层 socket 负责将加密数据包发送到网络。

- **关键代码片段**：
  ```c
  ret = kernel_sendpage(
      tsk->socket, tsk->pages_send, /* offset */ tsk->send_offset,
      tsk->send_len + KTLS_OVERHEAD(tsk) - tsk->send_offset,
      MSG_DONTWAIT);
  ```
  - 这里 `kernel_sendpage` 调用底层 socket 的发送机制，将加密数据注入 TCP/UDP 协议栈。

 工作流程总结：
1. 用户数据通过 `msg_iov` 进入 `tls_sendmsg`。
2. 数据被加密并存储在 `tsk->pages_send`。
3. `tls_kernel_sendpage` 将加密数据通过 `tsk->socket` 发送。
4. 底层 socket 的协议栈（TCP 或 UDP）处理发送逻辑。

#### 3. `tls_recvmsg` 如何从底层 TCP/UDP socket 获取数据
`tls_recvmsg` 负责从底层 socket 接收数据，解密后传递给用户空间。它的实现依赖于 `tls_data_ready` 回调和 `strparser` 机制。

 实现细节：
- **数据就绪回调**：
  - 当底层 socket 有数据到达时，`tls_data_ready` 被触发（因为它替换了原始的 `sk_data_ready`）。
  - 对于 TLS（`SOCK_STREAM`），`strp_data_ready` 被调用，启动 `strparser` 解析数据。
  - 对于 DTLS（`SOCK_DGRAM`），`do_dtls_data_ready` 和 `dtls_udp_read_sock` 被调用，直接处理 UDP 数据包。

- **数据接收和解密**：
  - `tls_recvmsg` 调用 `tls_wait_data` 等待数据，数据从 `sk->sk_receive_queue` 队列中获取（由 `tls_queue` 填充）。
  - `decrypt_skb` 函数使用 `tls_do_decryption` 解密数据，更新 `sk_buff` 的偏移量和长度。
  - 解密后的数据通过 `skb_copy_datagram_msg` 填充到用户提供的 `msg_iov` 缓冲区。

- **底层 socket 的角色**：
  - 底层 socket 的接收队列（`sk_receive_queue`）由内核协议栈填充，KTLS 通过 `tsk->socket->sk` 访问这些数据。
  - 对于 TLS，`strparser` 负责从 TCP 流中提取 TLS 记录；对于 DTLS，`dtls_udp_read_sock` 从 UDP 队列中提取数据包。

- **关键代码片段**：
  ```c
  skb = tls_wait_data(tsk, flags, timeo, &err);
  if (!skb) goto recv_end;
  rxm = strp_rx_msg(skb);
  err = decrypt_skb(tsk, skb);
  err = skb_copy_datagram_msg(skb, rxm->offset, msg, chunk);
  ```
  - 这里 `tls_wait_data` 从底层 socket 队列获取数据，`decrypt_skb` 解密，`skb_copy_datagram_msg` 将数据传递给用户。

 工作流程总结：
1. 底层 socket 接收数据，触发 `tls_data_ready`。
2. 数据被放入 KTLS 的接收队列 (`sk->sk_receive_queue`)。
3. `tls_recvmsg` 从队列中获取 `sk_buff`，解密后填充到 `msg_iov`。
4. 用户空间接收解密后的明文数据。

#### 4. 为什么你可能感到困惑
- **间接性**：`tls_sendmsg` 和 `tls_recvmsg` 并未直接调用底层 socket 的 `sendmsg` 或 `recvmsg`，而是通过回调和工作队列间接操作。这是因为 KTLS 需要在数据传输前/后进行加密/解密，增加了额外的处理层。
- **异步性**：发送使用工作队列 (`tls_tx_work`)，接收依赖 `strparser` 或 `dtls_udp_read_sock`，这与直接的同步调用不同。
- **数据路径**：数据从用户空间进入 KTLS 后，被加密并通过 `kernel_sendpage` 注入底层 socket，接收时从底层 socket 队列提取后解密，路径较复杂。

#### 5. 总结
- **`tls_bind`** 替换了底层 socket 的读写回调 (`tls_data_ready` 和 `tls_write_space`)，将控制权交给 KTLS。
- **`tls_sendmsg`** 通过加密数据并调用 `kernel_sendpage` 将数据注入底层 TCP/UDP socket，底层协议栈负责网络传输。
- **`tls_recvmsg`** 通过 `tls_data_ready` 和 `tls_wait_data` 从底层 socket 接收数据，解密后传递给用户。
  这种设计实现了 TLS/DTLS 的加密传输，同时复用了现有 TCP/UDP 协议栈的实现。